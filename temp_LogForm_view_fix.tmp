import React, { useState, useEffect, useRef } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import { Form, Button, Spinner, Alert } from 'react-bootstrap';
import moment from 'moment';
import toast from 'react-hot-toast';

const getLogsFromStorage = () => {
  const logs = localStorage.getItem('voiceLogs');
  return logs ? JSON.parse(logs) : [];
};

const saveLogsToStorage = (logs) => {
  localStorage.setItem('voiceLogs', JSON.stringify(logs));
};

const LogForm = () => {
  const [content, setContent] = useState('');
  const [logDate, setLogDate] = useState(moment().format('YYYY-MM-DD'));
  const [isLoading, setIsLoading] = useState(false);
  const [isFetching, setIsFetching] = useState(false);
  const [error, setError] = useState(null);
  const [isListening, setIsListening] = useState(false);
  const { id } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const isEditing = !!id;

  const recognitionRef = useRef(null);
  const finalTranscriptRef = useRef('');

  const stopRecognition = () => {
    if (recognitionRef.current) {
      recognitionRef.current.stop();
      recognitionRef.current = null;
      setIsListening(false);
    }
  };

  const startRecognition = () => {
    if (isListening || recognitionRef.current) {
      stopRecognition();
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      toast.error('?듾슴?꾠겗?뽧꺀?╉궣??윹鶯계첀鈺섅굮?듐깮?쇈깉?쀣겍?꾠겲?쎼굯??);
      return;
    }

    const recognition = new SpeechRecognition();
    recognitionRef.current = recognition;
    recognition.continuous = true;
    recognition.lang = 'ko-KR';
    recognition.interimResults = true;

    recognition.onstart = () => {
      setIsListening(true);
      finalTranscriptRef.current = content;
    };

    recognition.onresult = (event) => {
      let interimTranscript = '';
      let finalTranscript = finalTranscriptRef.current;
      for (let i = event.resultIndex; i < event.results.length; ++i) {
        if (event.results[i].isFinal) {
          finalTranscript += event.results[i][0].transcript;
        } else {
          interimTranscript += event.results[i][0].transcript;
        }
      }
      finalTranscriptRef.current = finalTranscript;
      setContent(finalTranscript + interimTranscript);
    };

    recognition.onerror = (event) => {
      toast.error(`?뚯꽦 ?몄떇 ?ㅻ쪟: ${event.error}`);
      stopRecognition();
    };

    recognition.onend = () => {
      stopRecognition();
    };

    recognition.start();
  };

  useEffect(() => {
    const queryParams = new URLSearchParams(location.search);
    const startVoice = queryParams.get('voice') === 'true';
    if (startVoice && !isEditing) {
      startRecognition();
    }
    // Ensure recognition is stopped on unmount
    return () => stopRecognition();
  }, []); // Run only once on mount

  useEffect(() => {
    if (isEditing) {
      setIsFetching(true);
      const allLogs = getLogsFromStorage();
      const logId = parseInt(id, 10);
      const foundLog = allLogs.find(p => p.id === logId);
      if (foundLog) {
        setContent(foundLog.content);
        setLogDate(moment(foundLog.created_at).format('YYYY-MM-DD'));
      } else {
        toast.error('?대떦 湲곕줉??李얠쓣 ???놁뒿?덈떎.');
        setError('?대떦 ID??湲곕줉??李얠쓣 ???놁뒿?덈떎.');
      }
      setIsFetching(false);
    } else if (location.state?.selectedDate) {
      setLogDate(moment(location.state.selectedDate).format('YYYY-MM-DD'));
    }
  }, [isEditing, id, location.state]);

  const handleSubmit = (e) => {
    e.preventDefault();
    stopRecognition(); // Stop listening before saving
    setIsLoading(true);
    let allLogs = getLogsFromStorage();
    if (isEditing) {
      const logId = parseInt(id, 10);
      allLogs = allLogs.map(log => log.id === logId ? { ...log, content, created_at: moment(logDate).toISOString() } : log);
    } else {
      allLogs = [{ id: Date.now(), content, created_at: moment(logDate).toISOString() }, ...allLogs];
    }
    saveLogsToStorage(allLogs);
    setIsLoading(false);
    toast.success(isEditing ? '湲곕줉???섏젙?섏뿀?듬땲??' : '??湲곕줉???묒꽦?섏뿀?듬땲??');
    navigate('/');
  };

  if (isFetching) {
    return <div className="text-center"><Spinner animation="border" /></div>;
  }

  return (
    <div>
      <h1>{isEditing ? '湲곕줉 ?섏젙' : '??湲곕줉 ?묒꽦'}</h1>
      <hr />
      <Form onSubmit={handleSubmit}>
        <Form.Group className="mb-3" controlId="formLogDate">
          <Form.Label>湲곕줉 ?좎쭨</Form.Label>
          <Form.Control type="date" value={logDate} onChange={(e) => setLogDate(e.target.value)} required />
        </Form.Group>

        <Form.Group className="mb-3" controlId="formContent">
          <div className="d-flex justify-content-between align-items-center">
            <Form.Label>湲곕줉 ?댁슜</Form.Label>
            <Button variant={isListening ? 'danger' : 'outline-primary'} size="sm" onClick={isListening ? stopRecognition : startRecognition}>
              {isListening ? '?뵶 ?몄떇 以묒?' : '?렎 ?뚯꽦?쇰줈 ?낅젰'}
            </Button>
          </div>
          <Form.Control as="textarea" rows={10} placeholder="?뚯꽦?쇰줈 ?낅젰 踰꾪듉???꾨Ⅴ怨?留먯??섏떆嫄곕굹, 吏곸젒 ?낅젰?섏꽭??" value={content} onChange={(e) => setContent(e.target.value)} required />
        </Form.Group>

        {error && <Alert variant="danger" className="mt-3">{error}</Alert>}

        <div className="d-grid gap-2 d-md-flex justify-content-md-end">
          <Button variant="secondary" onClick={() => navigate(-1)} disabled={isLoading}>痍⑥냼</Button>
          <Button variant="primary" type="submit" disabled={isLoading}>{isLoading ? <Spinner as="span" size="sm" /> : (isEditing ? '?섏젙 ?꾨즺' : '?묒꽦 ?꾨즺')}</Button>
        </div>
      </Form>
    </div>
  );
};

export default LogForm;
